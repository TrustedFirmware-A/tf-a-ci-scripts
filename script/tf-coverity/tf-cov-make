#!/usr/bin/env bash
#
# Copyright (c) 2019-2023, Arm Limited. All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause
#

#
# This script builds the TF in different configs.
# Rather than telling cov-build to build TF using a simple 'make all' command,
# the goal here is to combine several build flags to analyse more of our source
# code in a single 'build'. The Coverity Scan service does not have the notion
# of separate types of build - there is just one linear sequence of builds in
# the project history.
#

# Bail out as soon as an error is encountered.
set -e

TF_SOURCES=$1
if [ ! -d "$TF_SOURCES" ]; then
    echo "ERROR: '$TF_SOURCES' does not exist or is not a directory"
    echo "Usage: $(basename "$0") <trusted-firmware-directory>"
    exit 1
fi

containing_dir="$(readlink -f "$(dirname "$0")/")"
. $containing_dir/common-def.sh

# Get mbed TLS library code to build Trusted Firmware with Trusted Board Boot
# support. The version of mbed TLS to use here must be the same as when
# building TF in the usual context.
if [ ! -d "$MBED_TLS_DIR" ]; then
    git clone -q --depth 1 -b "$MBED_TLS_SOURCES_TAG" "$MBED_TLS_URL_REPO" "$MBED_TLS_DIR"
fi

cd "$TF_SOURCES"

# Clean TF source dir to make sure we don't analyse temporary files.
make distclean

#
# Build TF in different configurations to get as much coverage as possible
#

#
# FVP platform
# We'll use the following flags for all FVP builds.
#
fvp_common_flags="$(common_flags) PLAT=fvp"

# Try all possible SPDs.
clean_build $fvp_common_flags ${ARM_TBB_OPTIONS} ARM_TSP_RAM_LOCATION=dram SPD=tspd
clean_build $fvp_common_flags ${ARM_TBB_OPTIONS} ARM_TSP_RAM_LOCATION=dram SPD=tspd TSP_INIT_ASYNC=1 \
    TSP_NS_INTR_ASYNC_PREEMPT=1
clean_build $fvp_common_flags ${ARM_TBB_OPTIONS} SPD=opteed
clean_build $fvp_common_flags ${ARM_TBB_OPTIONS} SPD=tlkd
clean_build $fvp_common_flags ${ARM_TBB_OPTIONS} SPD=pncd SPD_PNCD_NS_IRQ=126 SPD_PNCD_S_IRQ=15

# Dualroot chain of trust.
clean_build $fvp_common_flags ${ARM_TBB_OPTIONS} SPD=tspd COT=dualroot

# FEAT_RME with CCA chain of trust.
#
# Note that we override PLAT_RSS_NOT_SUPPORTED build flag (which defaults to 1
# on the Base AEM FVP) just to analyse the RSS communication driver code through
# Coverity. In reality, RSS is not supported on FVP right now (or on any other
# upstream platform, for that matter) so the resulting firmware would not be
# functional.
clean_build $fvp_common_flags ${ARM_TBB_OPTIONS} USE_ROMLIB=1 \
	    ENABLE_RME=1 MEASURED_BOOT=1 PLAT_RSS_NOT_SUPPORTED=0

clean_build $fvp_common_flags SPD=trusty
clean_build $fvp_common_flags SPD=trusty TRUSTY_SPD_WITH_GENERIC_SERVICES=1

# ERRATA ABI
clean_build $fvp_common_flags ERRATA_ABI_SUPPORT=1

# SDEI
clean_build $fvp_common_flags SDEI_SUPPORT=1 EL3_EXCEPTION_HANDLING=1

# SDEI with fconf
clean_build $fvp_common_flags SDEI_IN_FCONF=1 SDEI_SUPPORT=1 EL3_EXCEPTION_HANDLING=1

# PCI Service
clean_build $fvp_common_flags SMC_PCI_SUPPORT=1

# Secure interrupt descriptors with fconf
clean_build $fvp_common_flags SEC_INT_DESC_IN_FCONF=1

# Without coherent memory
clean_build $fvp_common_flags ${ARM_TBB_OPTIONS} ARM_TSP_RAM_LOCATION=dram SPD=tspd USE_COHERENT_MEM=0

# Using PSCI extended State ID format rather than the original format
clean_build $fvp_common_flags ${ARM_TBB_OPTIONS} ARM_TSP_RAM_LOCATION=dram SPD=tspd PSCI_EXTENDED_STATE_ID=1 \
    ARM_RECOM_STATE_ID_ENC=1

# Alternative boot flows (This changes some of the platform initialisation code)
clean_build $fvp_common_flags EL3_PAYLOAD=0x80000000
clean_build $fvp_common_flags PRELOADED_BL33_BASE=0x80000000

# Using the SP804 timer instead of the Generic Timer
clean_build $fvp_common_flags FVP_USE_SP804_TIMER=1

# Using the CCN driver and multi cluster topology
clean_build $fvp_common_flags FVP_CLUSTER_COUNT=4

# PMF
clean_build $fvp_common_flags ENABLE_PMF=1

# stack protector
clean_build $fvp_common_flags ENABLE_STACK_PROTECTOR=strong

# AArch32 build
clean_build $fvp_common_flags CROSS_COMPILE=arm-none-eabi- \
    ARCH=aarch32 AARCH32_SP=sp_min \
    RESET_TO_SP_MIN=1 PRELOADED_BL33_BASE=0x80000000
clean_build $fvp_common_flags CROSS_COMPILE=arm-none-eabi- \
    ARCH=aarch32 AARCH32_SP=sp_min

# Xlat tables lib version 1 (AArch64 and AArch32)
clean_build $fvp_common_flags ARM_XLAT_TABLES_LIB_V1=1 RECLAIM_INIT_CODE=0
clean_build $fvp_common_flags CROSS_COMPILE=arm-none-eabi- \
    ARCH=aarch32 AARCH32_SP=sp_min ARM_XLAT_TABLES_LIB_V1=1 RECLAIM_INIT_CODE=0

# SPM support based on Management Mode Interface Specification
clean_build $fvp_common_flags SPM_MM=1 EL3_EXCEPTION_HANDLING=1 ENABLE_SVE_FOR_NS=0

# SPM support with TOS(optee) as SPM sitting at S-EL1
clean_build $fvp_common_flags SPD=spmd SPMD_SPM_AT_SEL2=0

# SPM support with SPM at EL3 and TSP at S-EL1
clean_build $fvp_common_flags CTX_INCLUDE_PAUTH_REGS=1 CTX_INCLUDE_EL2_REGS=0 EL3_EXCEPTION_HANDLING=0 \
       	SPD=spmd SPMD_SPM_AT_SEL2=0 SPMC_AT_EL3=1 \
       	ARM_SPMC_MANIFEST_DTS=plat/arm/board/fvp/fdts/fvp_tsp_sp_manifest.dts

# SPM support with Secure hafnium as SPM sitting at S-EL2
# SP_LAYOUT_FILE is used only during FIP creation but build won't progress
# if we have NULL value to it, so passing a dummy string.
clean_build $fvp_common_flags SPD=spmd SPMD_SPM_AT_SEL2=1 ARM_ARCH_MINOR=4 \
	CTX_INCLUDE_EL2_REGS=1 SP_LAYOUT_FILE=dummy

# SPM support with SPM sitting at EL3
clean_build $fvp_common_flags SPD=spmd SPMD_SPM_AT_SEL2=0 SPMC_AT_EL3=1

#BL2 at EL3 support
clean_build $fvp_common_flags RESET_TO_BL2=1
clean_build $fvp_common_flags CROSS_COMPILE=arm-none-eabi- \
    ARCH=aarch32 AARCH32_SP=sp_min RESET_TO_BL2=1

# RAS Extension Support
clean_build $fvp_common_flags EL3_EXCEPTION_HANDLING=1 ENABLE_FEAT_RAS=1 \
    RAS_FFH_SUPPORT=1 FAULT_INJECTION_SUPPORT=1 HANDLE_EA_EL3_FIRST_NS=1 \
    SDEI_SUPPORT=1 PLATFORM_TEST_RAS_FFH=1

# EA handled in EL3 first
clean_build $fvp_common_flags HANDLE_EA_EL3_FIRST_NS=1 PLATFORM_TEST_EA_FFH=1

# Hardware Assisted Coherency(DynamIQ)
clean_build $fvp_common_flags FVP_CLUSTER_COUNT=1 FVP_MAX_CPUS_PER_CLUSTER=8 \
    HW_ASSISTED_COHERENCY=1 USE_COHERENT_MEM=0

# Pointer Authentication Support
clean_build $fvp_common_flags CTX_INCLUDE_PAUTH_REGS=1 \
    ARM_ARCH_MINOR=5 EL3_EXCEPTION_HANDLING=1 BRANCH_PROTECTION=1 SDEI_SUPPORT=1 SPD=tspd TSP_NS_INTR_ASYNC_PREEMPT=1

# Undefined Behaviour Sanitizer
# Building with UBSAN SANITIZE_UB=on increases the executable size.
# Hence it is only properly supported in bl31 with RESET_TO_BL31 enabled
make $fvp_common_flags clean
make $fvp_common_flags SANITIZE_UB=on RESET_TO_BL31=1 bl31

# debugfs feature
clean_build $fvp_common_flags DEBUG=1 USE_DEBUGFS=1

# MPAM feature
clean_build $fvp_common_flags ENABLE_MPAM_FOR_LOWER_ELS=1

# Using GICv3.1 driver with extended PPI and SPI range
clean_build $fvp_common_flags GIC_EXT_INTID=1

# Using GICv4 features with extended PPI and SPI range
clean_build $fvp_common_flags GIC_ENABLE_V4_EXTN=1 GIC_EXT_INTID=1

# Measured Boot
clean_build $fvp_common_flags ${ARM_TBB_OPTIONS} MBOOT_EL_HASH_ALG=sha256 MEASURED_BOOT=1 USE_ROMLIB=1

# DRTM
clean_build $fvp_common_flags ${ARM_TBB_OPTIONS} TPM_HASH_ALG=sha256 DRTM_SUPPORT=1 USE_ROMLIB=1

# CoT descriptors in device tree
clean_build $fvp_common_flags ${ARM_TBB_OPTIONS} COT_DESC_IN_DTB=1 USE_ROMLIB=1

# PSA FWU support - Disable debug build for this option as its causing bl31 image overflow
clean_build $fvp_common_flags ${ARM_TBB_OPTIONS} ARM_GPT_SUPPORT=1 PSA_FWU_SUPPORT=1 USE_ROMLIB=1 DEBUG=0

# SME and HCX features
clean_build $fvp_common_flags ENABLE_SME_FOR_NS=1 ENABLE_FEAT_HCX=1

# SME2
clean_build $fvp_common_flags ENABLE_SME2_FOR_NS=1 ENABLE_SME_FOR_NS=1 ENABLE_FEAT_HCX=1

# Architectural Feature Detection mechanism
clean_build $fvp_common_flags FEATURE_DETECTION=1

# RNG trap feature
clean_build $fvp_common_flags ENABLE_FEAT_RNG=1 ENABLE_FEAT_RNG_TRAP=1

# OPTEE_ALLOW_SMC_LOAD feature - Disable debug build for this option as its causing bl31 image overflow
clean_build $fvp_common_flags ${ARM_TBB_OPTIONS} SPD=opteed OPTEE_ALLOW_SMC_LOAD=1 PLAT_XLAT_TABLES_DYNAMIC=1 DEBUG=0

#
# Juno platform
# We'll use the following flags for all Juno builds.
#
juno_common_flags="$(common_flags) PLAT=juno"
clean_build $juno_common_flags SPD=tspd ${ARM_TBB_OPTIONS}
clean_build $juno_common_flags EL3_PAYLOAD=0x80000000
clean_build $juno_common_flags ENABLE_STACK_PROTECTOR=strong ARM_ETHOSN_NPU_DRIVER=1
clean_build $juno_common_flags ${ARM_TBB_OPTIONS} ENABLE_STACK_PROTECTOR=strong ARM_ETHOSN_NPU_DRIVER=1 ARM_ETHOSN_NPU_TZMP1=1
clean_build $juno_common_flags CSS_USE_SCMI_SDS_DRIVER=0

clean_build $juno_common_flags SPD=tspd ${ARM_TBB_OPTIONS} ARM_CRYPTOCELL_INTEG=1 CCSBROM_LIB_PATH=${CRYPTOCELL_LIB_PATH} KEY_SIZE=2048

# TRNG Service
clean_build $juno_common_flags TRNG_SUPPORT=1

#
# System Guidance for Infrastructure platform RD-E1Edge
#
make $(common_flags) PLAT=rde1edge ${ARM_TBB_OPTIONS} CSS_SGI_CHIP_COUNT=1 all

#
# Reference Design platform RD-V1
#
make $(common_flags) PLAT=rdv1 ${ARM_TBB_OPTIONS} all

#
# Reference Design platform RD-V1-MC
#
make $(common_flags) PLAT=rdv1mc ${ARM_TBB_OPTIONS} CSS_SGI_CHIP_COUNT=4 all

#
# Reference Design Platform RD-N2
#
make $(common_flags) PLAT=rdn2 ${ARM_TBB_OPTIONS} all

#
# Neoverse N1 SDP platform
#
make $(common_flags) PLAT=n1sdp ${ARM_TBB_OPTIONS} all

#
# FVP VE platform
#
make $(common_flags) PLAT=fvp_ve AARCH32_SP=sp_min ARCH=aarch32 \
    CROSS_COMPILE=arm-none-eabi- ARM_ARCH_MAJOR=7 \
    ARM_CORTEX_A5=yes ARM_XLAT_TABLES_LIB_V1=1 \
    FVP_HW_CONFIG_DTS=fdts/fvp-ve-Cortex-A5x1.dts all

#
# A5 DesignStart Platform
#
make $(common_flags) PLAT=a5ds AARCH32_SP=sp_min ARCH=aarch32 \
    ARM_ARCH_MAJOR=7 ARM_CORTEX_A5=yes ARM_XLAT_TABLES_LIB_V1=1 \
    CROSS_COMPILE=arm-none-eabi- FVP_HW_CONFIG_DTS=fdts/a5ds.dts

#
# Corstone700 Platform
#

corstone700_common_flags="CROSS_COMPILE=arm-none-eabi- \
                          $(common_flags) \
                          PLAT=corstone700 \
                          ARCH=aarch32 \
                          RESET_TO_SP_MIN=1 \
                          AARCH32_SP=sp_min \
                          ARM_LINUX_KERNEL_AS_BL33=0 \
                          ARM_PRELOADED_DTB_BASE=0x80400000 \
                          ENABLE_PIE=1 \
                          ENABLE_STACK_PROTECTOR=all \
                          all"

echo "Info: Building Corstone700 FVP ..."

make TARGET_PLATFORM=fvp ${corstone700_common_flags}

echo "Info: Building Corstone700 FPGA ..."

make TARGET_PLATFORM=fpga ${corstone700_common_flags}

#
# Arm internal FPGA port
#
make PLAT=arm_fpga $(common_flags release) \
    FPGA_PRELOADED_DTB_BASE=0x88000000 PRELOADED_BL33_BASE=0x82080000 all

#
# Total Compute platforms
#
make $(common_flags) PLAT=tc TARGET_PLATFORM=0 ${ARM_TBB_OPTIONS} all
make $(common_flags) PLAT=tc TARGET_PLATFORM=1 ${ARM_TBB_OPTIONS} all
make $(common_flags) PLAT=tc TARGET_PLATFORM=2 ${ARM_TBB_OPTIONS} MEASURED_BOOT=1 all

#
# Morello platform
#
clean_build $(common_flags) PLAT=morello TARGET_PLATFORM=fvp ${ARM_TBB_OPTIONS}
clean_build $(common_flags) PLAT=morello TARGET_PLATFORM=soc ${ARM_TBB_OPTIONS}

#
# corstone1000 Platform
#

make $(common_flags) \
     PLAT=corstone1000 \
     SPD=spmd \
     TARGET_PLATFORM=fpga \
     ENABLE_STACK_PROTECTOR=strong \
     ENABLE_PIE=1 \
     RESET_TO_BL2=1 \
     SPMD_SPM_AT_SEL2=0 \
     ${ARM_TBB_OPTIONS} \
     CREATE_KEYS=1 \
     COT=tbbr \
     ROT_KEY=plat/arm/board/common/rotpk/arm_rotprivk_rsa.pem \
     bl2 \
     bl31

#
# FVP-R platform
#
clean_build $(common_flags) PLAT=fvp_r ${ARM_TBB_OPTIONS} ENABLE_STACK_PROTECTOR=all

# Partners' platforms.
# Enable as many features as possible.
# We don't need to clean between each build here because we only do one build
# per platform so we don't hit the build flags dependency problem.

# Platforms from Mediatek
make PLAT=mt8173 $(common_flags) all
make PLAT=mt8183 $(common_flags) all
make PLAT=mt8186 $(common_flags) COREBOOT=1 all
make PLAT=mt8188 $(common_flags) COREBOOT=1 all
make PLAT=mt8192 $(common_flags) COREBOOT=1 all
make PLAT=mt8195 $(common_flags) COREBOOT=1 all

# Platforms from Qualcomm
make PLAT=sc7180 $(common_flags) COREBOOT=1 all

make PLAT=rk3288 CROSS_COMPILE=arm-none-eabi- \
    $(common_flags) ARCH=aarch32 AARCH32_SP=sp_min all
make PLAT=rk3368 $(common_flags) COREBOOT=1 \
    ENABLE_STACK_PROTECTOR=strong all
make PLAT=rk3399 $(common_flags) COREBOOT=1 PLAT_RK_DP_HDCP=1 \
    ENABLE_STACK_PROTECTOR=strong all
make PLAT=rk3328 $(common_flags) COREBOOT=1 PLAT_RK_SECURE_DDR_MINILOADER=1 \
    ENABLE_STACK_PROTECTOR=strong all
make PLAT=px30 $(common_flags) PLAT_RK_SECURE_DDR_MINILOADER=1 \
    ENABLE_STACK_PROTECTOR=strong all

# Although we do several consecutive builds for the Tegra platform below, we
# don't need to clean between each one because the Tegra makefiles specify
# a different build directory per SoC.
make PLAT=tegra TARGET_SOC=t210 $(common_flags) all
make PLAT=tegra TARGET_SOC=t186 $(common_flags) all
make PLAT=tegra TARGET_SOC=t194 $(common_flags) all

# For the Xilinx platform, artificially increase the extents of BL31 memory
# (using the platform-specific build options ZYNQMP_ATF_MEM_{BASE,SIZE}).
# If we keep the default values, BL31 doesn't fit when it is built with all
# these build flags.
make PLAT=zynqmp $(common_flags) \
    RESET_TO_BL31=1 SPD=tspd \
    SDEI_SUPPORT=1 \
    ZYNQMP_ATF_MEM_BASE=0xFFFC0000 ZYNQMP_ATF_MEM_SIZE=0x00040000 \
    all

# Build both for silicon (default) and virtual QEMU platform.
clean_build PLAT=versal $(common_flags)
clean_build PLAT=versal $(common_flags) VERSAL_PLATFORM=versal_virt

# Build Xilinx Versal NET platform
clean_build PLAT=versal_net $(common_flags)

# Build Xilinx Versal NET without Platform Management support
clean_build PLAT=versal_net $(common_flags) TFA_NO_PM=1

# Platforms from Allwinner
clean_build PLAT=sun50i_a64 $(common_flags release) all
clean_build PLAT=sun50i_a64 $(common_flags release) SUNXI_PSCI_USE_NATIVE=0 all
clean_build PLAT=sun50i_a64 $(common_flags release) SUNXI_PSCI_USE_SCPI=0 all
clean_build PLAT=sun50i_a64 $(common_flags release) SUNXI_AMEND_DTB=1 all
clean_build PLAT=sun50i_h6 $(common_flags) all
clean_build PLAT=sun50i_h6 $(common_flags) SUNXI_PSCI_USE_NATIVE=0 all
clean_build PLAT=sun50i_h6 $(common_flags) SUNXI_PSCI_USE_SCPI=0 all
clean_build PLAT=sun50i_h616 $(common_flags) all
clean_build PLAT=sun50i_r329 $(common_flags) all

# Platforms from i.MX
make AARCH32_SP=optee ARCH=aarch32 ARM_ARCH_MAJOR=7 ARM_CORTEX_A7=yes \
    CROSS_COMPILE=arm-none-eabi- PLAT=warp7 ${TBB_OPTIONS} \
    $(common_flags) all
make AARCH32_SP=optee ARCH=aarch32 CROSS_COMPILE=arm-none-eabi- PLAT=picopi \
    $(common_flags) all
make PLAT=imx8mm $(common_flags) NEED_BL2=yes MEASURED_BOOT=1 \
    MBOOT_EL_HASH_ALG=sha256 ${TBB_OPTIONS} all
make PLAT=imx8mn $(common_flags) SDEI_SUPPORT=1 all
make PLAT=imx8mp $(common_flags) NEED_BL2=yes ${TBB_OPTIONS} all

# Due to the limited OCRAM space that can be used for TF-A, build test
# will report failure caused by too small RAM size, so comment out the
# build test for imx8mq in CI. It can also resolve the following ticket:
# https://developer.trustedfirmware.org/T626
#make PLAT=imx8mq $(common_flags release) all

make PLAT=imx8qm $(common_flags) all
make PLAT=imx8qx $(common_flags) all

# Platforms for NXP Layerscape
nxp_sb_flags="TRUSTED_BOARD_BOOT=1 CST_DIR=$(pwd) SPD=opteed"
nxp_sb_fuse_flags="${nxp_sb_flags} FUSE_PROG=1"

# Platform lx2
make PLAT=lx2160aqds $(common_flags) all
make PLAT=lx2160ardb $(common_flags) all

#CSF Based CoT:
clean_build PLAT=lx2162aqds $(common_flags) BOOT_MODE=flexspi_nor \
    $nxp_sb_fuse_flags DDR_PHY_BIN_PATH=$(pwd)

#X509 Based CoT
clean_build PLAT=lx2162aqds $(common_flags) BOOT_MODE=flexspi_nor \
    $nxp_sb_flags GENERATE_COT=1 \
    MBEDTLS_DIR=$(pwd)/mbedtls

#BOOT_MODE=emmc and Stack protector
clean_build PLAT=lx2162aqds $(common_flags) BOOT_MODE=emmc \
    $nxp_sb_fuse_flags ENABLE_STACK_PROTECTOR=strong

# Platform ls1028ardb
clean_build PLAT=ls1028ardb $(common_flags) all BOOT_MODE=flexspi_nor
clean_build PLAT=ls1028ardb $(common_flags) all BOOT_MODE=emmc
clean_build PLAT=ls1028ardb $(common_flags) all BOOT_MODE=sd

# ls1028a Secure Boot
clean_build PLAT=ls1028ardb $(common_flags) all BOOT_MODE=flexspi_nor $nxp_sb_fuse_flags
clean_build PLAT=ls1028ardb $(common_flags) all BOOT_MODE=emmc $nxp_sb_fuse_flags
clean_build PLAT=ls1028ardb $(common_flags) all BOOT_MODE=sd $nxp_sb_fuse_flags

# Platform ls1043ardb
clean_build PLAT=ls1043ardb $(common_flags) all BOOT_MODE=nor
clean_build PLAT=ls1043ardb $(common_flags) all BOOT_MODE=nand
clean_build PLAT=ls1043ardb $(common_flags) all BOOT_MODE=sd

# ls1043ardb Secure Boot
clean_build PLAT=ls1043ardb $(common_flags) all BOOT_MODE=nor $nxp_sb_fuse_flags
clean_build PLAT=ls1043ardb $(common_flags) all BOOT_MODE=nand $nxp_sb_fuse_flags
clean_build PLAT=ls1043ardb $(common_flags) all BOOT_MODE=sd $nxp_sb_fuse_flags

# ls1046ardb Secure Boot
clean_build PLAT=ls1046ardb $(common_flags) all BOOT_MODE=qspi $nxp_sb_fuse_flags
clean_build PLAT=ls1046ardb $(common_flags) all BOOT_MODE=sd $nxp_sb_fuse_flags
clean_build PLAT=ls1046ardb $(common_flags) all BOOT_MODE=emmc $nxp_sb_fuse_flags

# ls1046afrwy Secure Boot
clean_build PLAT=ls1046afrwy $(common_flags) all BOOT_MODE=qspi $nxp_sb_fuse_flags
clean_build PLAT=ls1046afrwy $(common_flags) all BOOT_MODE=sd $nxp_sb_fuse_flags

# ls1046aqds Secure Boot
clean_build PLAT=ls1046aqds $(common_flags) all BOOT_MODE=qspi $nxp_sb_fuse_flags
clean_build PLAT=ls1046aqds $(common_flags) all BOOT_MODE=sd $nxp_sb_fuse_flags
clean_build PLAT=ls1046aqds $(common_flags) all BOOT_MODE=nor $nxp_sb_fuse_flags
clean_build PLAT=ls1046aqds $(common_flags) all BOOT_MODE=nand $nxp_sb_fuse_flags

# ls1088ardb Secure Boot
clean_build PLAT=ls1088ardb $(common_flags) all BOOT_MODE=qspi $nxp_sb_fuse_flags
clean_build PLAT=ls1088ardb $(common_flags) all BOOT_MODE=sd $nxp_sb_fuse_flags

# ls1088aqds Secure Boot
clean_build PLAT=ls1088aqds $(common_flags) all BOOT_MODE=qspi $nxp_sb_fuse_flags
clean_build PLAT=ls1088aqds $(common_flags) all BOOT_MODE=sd $nxp_sb_fuse_flags
clean_build PLAT=ls1088aqds $(common_flags) all BOOT_MODE=nor $nxp_sb_fuse_flags

# Platforms from Intel
make PLAT=stratix10 $(common_flags) all
make PLAT=agilex $(common_flags) all
make PLAT=n5x $(common_flags) all

# Platforms from Broadcom
clean_build PLAT=stingray $(common_flags) BOARD_CFG=bcm958742t \
    INCLUDE_EMMC_DRIVER_ERASE_CODE=1 DRIVER_I2C_ENABLE=1
clean_build PLAT=stingray $(common_flags) BOARD_CFG=bcm958742t-ns3 \
    INCLUDE_EMMC_DRIVER_ERASE_CODE=1 USE_USB=yes

# Platforms from Marvell
make PLAT=a3700 $(common_flags) SCP_BL2=/dev/null CM3_SYSTEM_RESET=1 \
    A3720_DB_PM_WAKEUP_SRC=1 HANDLE_EA_EL3_FIRST_NS=1 all

# Source files from mv-ddr-marvell repository are necessary
# to build below four platforms
wget https://downloads.trustedfirmware.org/tf-a/mv-ddr-marvell/mv-ddr-marvell-5d41a995637de1dbc93f193db6ef0c8954cab316.tar.gz 2> /dev/null
tar -xzf mv-ddr-marvell-5d41a995637de1dbc93f193db6ef0c8954cab316.tar.gz 2> /dev/null
mv mv-ddr-marvell drivers/marvell/mv_ddr

# These platforms from Marvell have dependency on GCC-6.2.1 toolchain
make PLAT=a80x0 DEBUG=1 SCP_BL2=/dev/null BL33=/dev/null MV_DDR_PATH=$PWD/drivers/marvell/mv_ddr \
    CROSS_COMPILE="$(set_cross_compile_gcc_linaro_toolchain)" all mrvl_flash
make PLAT=a80x0_mcbin DEBUG=1 SCP_BL2=/dev/null BL33=/dev/null MV_DDR_PATH=$PWD/drivers/marvell/mv_ddr \
    CROSS_COMPILE="$(set_cross_compile_gcc_linaro_toolchain)" all mrvl_flash
make PLAT=a70x0 DEBUG=1 SCP_BL2=/dev/null BL33=/dev/null MV_DDR_PATH=$PWD/drivers/marvell/mv_ddr \
    CROSS_COMPILE="$(set_cross_compile_gcc_linaro_toolchain)" all mrvl_flash
make PLAT=a70x0_amc DEBUG=1 SCP_BL2=/dev/null BL33=/dev/null MV_DDR_PATH=$PWD/drivers/marvell/mv_ddr \
    CROSS_COMPILE="$(set_cross_compile_gcc_linaro_toolchain)" all mrvl_flash
make PLAT=a70x0_mochabin DEBUG=1 SCP_BL2=/dev/null BL33=/dev/null MV_DDR_PATH=$PWD/drivers/marvell/mv_ddr \
    CROSS_COMPILE="$(set_cross_compile_gcc_linaro_toolchain)" all mrvl_flash
make PLAT=a80x0_puzzle DEBUG=1 SCP_BL2=/dev/null BL33=/dev/null MV_DDR_PATH=$PWD/drivers/marvell/mv_ddr \
    CROSS_COMPILE="$(set_cross_compile_gcc_linaro_toolchain)" all mrvl_flash
make PLAT=t9130 DEBUG=1 SCP_BL2=/dev/null BL33=/dev/null MV_DDR_PATH=$PWD/drivers/marvell/mv_ddr \
    CROSS_COMPILE="$(set_cross_compile_gcc_linaro_toolchain)" all mrvl_flash
make PLAT=t9130_cex7_eval DEBUG=1 SCP_BL2=/dev/null BL33=/dev/null MV_DDR_PATH=$PWD/drivers/marvell/mv_ddr \
    CROSS_COMPILE="$(set_cross_compile_gcc_linaro_toolchain)" all mrvl_flash

# Removing the source files
rm -rf drivers/marvell/mv_ddr 2> /dev/null

# Platforms from Meson
make PLAT=gxbb $(common_flags) all
make PLAT=gxl $(common_flags) all
make PLAT=g12a $(common_flags) all

# Platforms from Renesas
# Renesas R-Car D3 Automotive SoC
clean_build PLAT=rcar $(common_flags) BL32=Makefile \
    BL33=Makefile LIFEC_DBSC_PROTECT_ENABLE=0 LSI=D3 \
    MBEDTLS_DIR=$(pwd)/mbedtls PMIC_ROHM_BD9571=0 \
    RCAR_AVS_SETTING_ENABLE=0 SPD=none RCAR_LOSSY_ENABLE=0 \
    RCAR_SA0_SIZE=0 RCAR_SYSTEM_SUSPEND=0 TRUSTED_BOARD_BOOT=1

# Renesas R-Car H3 Automotive SoC
clean_build PLAT=rcar $(common_flags) BL32=Makefile \
    BL33=Makefile MBEDTLS_DIR=$(pwd)/mbedtls LSI=H3 \
    MACHINE=ulcb  PMIC_LEVEL_MODE=0 RCAR_DRAM_LPDDR4_MEMCONF=0 \
    RCAR_DRAM_SPLIT=1 RCAR_GEN3_ULCB=1 SPD=opteed \
    TRUSTED_BOARD_BOOT=1

# Renesas R-Car H3N Automotive SoC
clean_build PLAT=rcar $(common_flags) BL32=Makefile \
    BL33=Makefile MBEDTLS_DIR=$(pwd)/mbedtls LSI=H3N \
    SPD=opteed TRUSTED_BOARD_BOOT=1

# Renesas R-Car M3 Automotive SoC
clean_build PLAT=rcar $(common_flags) BL32=Makefile \
    BL33=Makefile MBEDTLS_DIR=$(pwd)/mbedtls LSI=M3 \
    MACHINE=ulcb  PMIC_LEVEL_MODE=0 RCAR_DRAM_LPDDR4_MEMCONF=0 \
    RCAR_DRAM_SPLIT=2 RCAR_GEN3_ULCB=1 SPD=opteed \
    TRUSTED_BOARD_BOOT=1

# Renesas R-Car M3N Automotive SoC
clean_build PLAT=rcar $(common_flags) BL32=Makefile \
    BL33=Makefile MBEDTLS_DIR=$(pwd)/mbedtls LSI=M3N \
    MACHINE=ulcb  PMIC_LEVEL_MODE=0 RCAR_DRAM_LPDDR4_MEMCONF=0 \
    RCAR_GEN3_ULCB=1 SPD=opteed TRUSTED_BOARD_BOOT=1

# Renesas R-Car E3 Automotive SoC
clean_build PLAT=rcar $(common_flags) BL32=Makefile \
    BL33=Makefile MBEDTLS_DIR=$(pwd)/mbedtls LSI=E3 \
    RCAR_AVS_SETTING_ENABLE=0 RCAR_DRAM_DDR3L_MEMCONF=0 \
    RCAR_SA0_SIZE=0 SPD=opteed TRUSTED_BOARD_BOOT=1

# Renesas R-Car V3M Automotive SoC
clean_build PLAT=rcar $(common_flags) BL32=Makefile \
    MBEDTLS_DIR=$(pwd)/mbedtls BL33=Makefile LSI=V3M MACHINE=eagle \
    PMIC_ROHM_BD9571=0 RCAR_DRAM_SPLIT=0 RCAR_SYSTEM_SUSPEND=0 \
    AVS_SETTING_ENABLE=0 SPD=none TRUSTED_BOARD_BOOT=1

# Renesas HiHope RZ/G2M development kit
clean_build PLAT=rzg $(common_flags) \
    MBEDTLS_DIR=$(pwd)/mbedtls LSI=G2M \
    RCAR_DRAM_SPLIT=2 RCAR_LOSSY_ENABLE=1 SPD=none

# Platforms from ST
stm32mp1_common_flags="$(common_flags) \
		       ARCH=aarch32 \
		       ARM_ARCH_MAJOR=7 \
		       CROSS_COMPILE=arm-none-eabi- \
		       ENABLE_STACK_PROTECTOR=strong \
		       PLAT=stm32mp1"

# STM32MP1 SDMMC boot
make ${stm32mp1_common_flags} STM32MP_SDMMC=1 \
    BUILD_PLAT=build/stm32mp1-sdmmc/debug \
    AARCH32_SP=sp_min bl2 bl32

# STM32MP1 eMMC boot
make ${stm32mp1_common_flags} STM32MP_EMMC=1 \
    BUILD_PLAT=build/stm32mp1-emmc/debug \
    AARCH32_SP=sp_min bl2 bl32

# STM32MP1 Raw NAND boot
make ${stm32mp1_common_flags} STM32MP_RAW_NAND=1 \
    BUILD_PLAT=build/stm32mp1-nand/debug \
    AARCH32_SP=sp_min bl2 bl32

# STM32MP1 SPI NAND boot
make ${stm32mp1_common_flags} STM32MP_SPI_NAND=1 \
    BUILD_PLAT=build/stm32mp1-snand/debug \
    AARCH32_SP=sp_min bl2 bl32

# STM32MP1 SPI NOR boot
make ${stm32mp1_common_flags} STM32MP_SPI_NOR=1 \
    BUILD_PLAT=build/stm32mp1-snor/debug \
    AARCH32_SP=sp_min bl2 bl32

# STM32MP1 UART boot
make ${stm32mp1_common_flags} STM32MP_UART_PROGRAMMER=1 \
    BUILD_PLAT=build/stm32mp1-uart/debug \
    AARCH32_SP=sp_min bl2 bl32

# STM32MP1 USB boot
make ${stm32mp1_common_flags} STM32MP_USB_PROGRAMMER=1 \
    BUILD_PLAT=build/stm32mp1-usb/debug \
    AARCH32_SP=sp_min bl2 bl32

# STM32MP1 TBBR
make ${stm32mp1_common_flags} STM32MP_SDMMC=1 \
    BUILD_PLAT=build/stm32mp1-sdmmc-tbbr/debug \
    MBEDTLS_DIR=$(pwd)/mbedtls TRUSTED_BOARD_BOOT=1 \
    AARCH32_SP=sp_min bl2 bl32

stm32mp13_common_flags="${stm32mp1_common_flags} \
			AARCH32_SP=optee \
			STM32MP13=1"

# STM32MP13 SDMMC boot
make ${stm32mp13_common_flags} STM32MP_SDMMC=1 \
    BUILD_PLAT=build/stm32mp1-mp13-sdmmc/debug bl2

# STM32MP13 TBBR
make ${stm32mp13_common_flags} STM32MP_SDMMC=1 \
    MBEDTLS_DIR=$(pwd)/mbedtls TRUSTED_BOARD_BOOT=1 \
    BUILD_PLAT=build/stm32mp1-mp13-sdmmc-tbbr/debug bl2

# STM32MP13 TBBR DECRYPTION AES GCM
make ${stm32mp13_common_flags} STM32MP_SDMMC=1 \
    MBEDTLS_DIR=$(pwd)/mbedtls TRUSTED_BOARD_BOOT=1 \
    DECRYPTION_SUPPORT=aes_gcm ENCRYPT_BL32=1 \
    BUILD_PLAT=build/stm32mp1-mp13-sdmmc-tbbr-dec/debug bl2

# Platforms from TI
make PLAT=k3 $(common_flags) all
make PLAT=k3 TARGET_BOARD=j784s4 $(common_flags) all

clean_build PLAT=qemu $(common_flags) ${TBB_OPTIONS}
# Use GICV3 driver
clean_build PLAT=qemu $(common_flags) QEMU_USE_GIC_DRIVER=QEMU_GICV3 \
    ENABLE_STACK_PROTECTOR=strong
# Use encrypted FIP feature.
clean_build PLAT=qemu $(common_flags) ${TBB_OPTIONS} \
    BL32_RAM_LOCATION=tdram DECRYPTION_SUPPORT=aes_gcm ENCRYPT_BL31=1 \
    ENCRYPT_BL32=1 FW_ENC_STATUS=0 SPD=opteed
# QEMU with SPMD support
clean_build PLAT=qemu $(common_flags) BL32=Makefile \
    BL32_RAM_LOCATION=tdram ARM_BL31_IN_DRAM=1 \
    SPD=spmd CTX_INCLUDE_EL2_REGS=0 SPMD_SPM_AT_SEL2=0 SPMC_OPTEE=1
# Measured Boot
clean_build PLAT=qemu $(common_flags) ${TBB_OPTIONS} MBOOT_EL_HASH_ALG=sha256 MEASURED_BOOT=1

clean_build PLAT=qemu_sbsa $(common_flags)

# QEMU with SPM support
clean_build PLAT=qemu_sbsa $(common_flags) BL32=Makefile SPM_MM=1 \
    EL3_EXCEPTION_HANDLING=1 ENABLE_SME_FOR_NS=0 ENABLE_SVE_FOR_NS=0

# For hikey enable PMF to include all files in the platform port
make PLAT=hikey $(common_flags) ${TBB_OPTIONS} ENABLE_PMF=1 all
make PLAT=hikey960 $(common_flags) ${TBB_OPTIONS} all
make PLAT=hikey960 $(common_flags) ${TBB_OPTIONS} SPD=spmd SPMC_AT_EL3=1 \
    SPMD_SPM_AT_SEL2=0 BL32=optee PLAT_SP_MANIFEST_DTS=foo NEED_FDT=no all
make PLAT=poplar $(common_flags) all

# Platforms from Socionext
clean_build PLAT=uniphier $(common_flags) ${TBB_OPTIONS} SPD=tspd
clean_build PLAT=uniphier $(common_flags) FIP_GZIP=1

clean_build PLAT=synquacer $(common_flags) SPM_MM=1 \
    RESET_TO_BL31=1 EL3_EXCEPTION_HANDLING=1 ENABLE_SVE_FOR_NS=0 \
    PRELOADED_BL33_BASE=0x0

# Support for SCP Message Interface protocol with platform specific drivers
clean_build PLAT=synquacer $(common_flags) \
    RESET_TO_BL31=1 PRELOADED_BL33_BASE=0x0 SQ_USE_SCMI_DRIVER=1

# Support for BL2 and TBBR
clean_build PLAT=synquacer $(common_flags) \
    MBEDTLS_DIR=$(pwd)/mbedtls TRUSTED_BOARD_BOOT=1 \
    SQ_USE_SCMI_DRIVER=1 SPD=opteed all

make PLAT=poplar $(common_flags) all

# Raspberry Pi Platforms
make PLAT=rpi3 $(common_flags) ${TBB_OPTIONS} \
    ENABLE_STACK_PROTECTOR=strong PRELOADED_BL33_BASE=0xDEADBEEF all
clean_build PLAT=rpi4 $(common_flags) SMC_PCI_SUPPORT=1 all

# A113D (AXG) platform.
clean_build PLAT=axg $(common_flags) SPD=opteed
clean_build PLAT=axg $(common_flags) AML_USE_ATOS=1

# QTI MSM8916 platform
clean_build PLAT=msm8916 $(common_flags)

# Platforms from Aspeed
clean_build PLAT=ast2700 $(common_flags) SPD=opteed

cd ..
